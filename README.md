# 개요
지난 교육에서 배운 내용을 다시 사용하여  복습하고, 배우지 못하거나 생각하지 못했던 부분을 추가하는 것을 목표로 커뮤니티 사이트  개발
# 목차
 - [보안](#보안)
	 - [HTTPS](#https)
	 - [해시 알고리즘](#해시-알고리즘)
	 - [접근 제한](#접근-제한)
 - [쿠키와 섹션](#쿠키와-세션)
 - [삭제와 복구](#삭제와-복구)
# 보안
풀스택 개발자 양성 과정을 통해 Spring이나 mybatis 등 다양한 기술을 배웠지만 보안적인 부분이 부족했던 것 같습니다. 그래서 대학교 때 배웠던 부분과 면접 때 질문받았던 내용을 추가하여 부족한 보안의 내용을 보완했습니다.
## HTTPS
HTTPS는 HTTP에 SSL을 추가하여 보안을 강화한 방법입니다.

SSL은 클라이언트와 서버 간의 통신을 공인된 제 3자(CA) 업체가 보증하는 방법으로, 통신 내용이 노출되고 변경되는 것을 방지하고 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지 확인할 수 있게 해줍니다.

![ssl 통신 과정](https://user-images.githubusercontent.com/38309884/109752936-a68f2d00-7c24-11eb-961e-07ee4af411eb.PNG)
다음 사진은 SSL의 통신 방식입니다. 최종적으로 서로 데이터를 주고받기 위해 대칭 키 암호화 방식을 사용하고 이 대칭 키를 만들기 위해 공개키 방식과 전자 서명이 사용됩니다.

![인증서 생성](https://user-images.githubusercontent.com/38309884/109758148-79e01300-7c2e-11eb-99f5-2582197c5c5c.PNG)
인증서를 만들기 위해 keytool을 사용했습니다.
|옵션|설명  |
|--|--|
| -alias |키의 별칭을 지정합니다  |
|-certreq|인증서  요청을  생성합니다.|
|-changealias|항목의  별칭을  변경합니다.|
|-delete|항목을  삭제합니다.|
|-exportcert|인증서를  익스포트합니다.|
|**-genkey**|**키를**  **생성합니다**.|
|-genkeypair|키  쌍을  생성합니다.|
|-genseckey|보안  키를  생성합니다.|
|-gencert|인증서  요청에서  인증서를  생성합니다.|
|-importcert|인증서  또는  인증서  체인을  임포트합니다.|
|-importpass|비밀번호를  임포트합니다.|
|-importkeystore|다른  키  저장소에서  하나  또는  모든  항목을  임포트합니다.|
|**-keyalg**|**키**  **생성**  **알고리즘을**  **지정합니다**.|
|**-keypasswd**|**항목의**  **키**  **비밀번호를**  **변경합니다**.|
|-keysize|키  사이즈를  지정합니다.|
|**-keystore**|**키**  **저장파일**|
|**-list**|**키**  **저장소의**  **항목을**  **나열합니다**.|
|-printcert|인증서  요청의  콘텐츠를  인쇄합니다.|
|-printcertreq|인증서의  알고리즘을  지정합니다. (해시  알고리즘으로  구성)|
|-sigalg|파일의  콘텐츠를  인쇄합니다.|
|-printcrlCRL|**키**  **저장소의**  **저장소**  **비밀번호를**  **변경합니다**.|
|**-storepasswd**||
|**-v**|**결과를**  **상세하게**  **보여줍니다**.|
|**-validity**|**인증서의**  **유효기간을**  **설정합니다**.|

![톰캣 설정](https://user-images.githubusercontent.com/38309884/109756235-e78a4000-7c2a-11eb-94e5-453fefd65364.PNG)
톰캣에서 https를 사용하기 위해 넣어준 세팅입니다.
세팅 후 이클립스에서 톰캣 설정을 보면 포트에 SSL이 바로 추가가 안 됩니다. 이 경우 톰캣을 다시 등록하면 설정한 SSL이 추가되는 것을 확인할 수 있습니다.
![http로 시도할 경우](https://user-images.githubusercontent.com/38309884/109755643-b2c9b900-7c29-11eb-8f54-a630ebbe7d01.PNG)
https로 설정한 포트가 443번인데 http로 접근을 시도할 경우 나타나는 메시지입니다.
![https 첫 시도](https://user-images.githubusercontent.com/38309884/109755644-b2c9b900-7c29-11eb-940c-a41cce6dea4b.PNG)
https로 시도할 경우 연결이 비공개로 설정되어 있지 않습니다라는 내용이 보이고, 안전하지 않음(으)로 이동 버튼을 클릭할 경우 이동할 수 있습니다.
![https_asdasd](https://user-images.githubusercontent.com/38309884/109755645-b3624f80-7c29-11eb-88d6-2fe1b38074d6.png)
이동 후 URL을 확인하면 다음과 같이 경고 표시가 나온 것을 확인할 수 있습니다.
![인증서](https://user-images.githubusercontent.com/38309884/109755648-b3624f80-7c29-11eb-807f-c57265ac2cc8.PNG)
인증서를 확인할 경우 위에 사진과 같은 내용을 확인할 수 있습니다. 이렇게 나타난 이유는 SSL의 통신 방식에서 CA에서 발급된 인증서인지 확인하는 과정이 있는데 그 부분에 대한 세팅을 안 해서 나타난 것으로 예상됩니다. 추후 무료로 이용할 수 있는 CA를 찾은 후 그다음 작업을 진행할 계획입니다.


## 해시 알고리즘
지금 이 프로젝트를 진행하기 전에는 DB에 모든 값을 그대로 저장했습니다. 그러다 보니 로그인 이후에 사용할 수 있는 기능들을 확인할 때 DB에 저장된 아이디와 비밀번호를 찾아서 로그인한 경험이 있습니다. 다시 생각해보면 DB에 접근할 수 있으면 다른 사람들의 정보를 쉽게 볼 수 있고 특히 사용자의 로그인 정보를 가져갈 수 있는 위험한 상황이 올 수 있다는 것을 느꼈고, 이 부분을 보완하고자 비밀번호에 해시 알고리즘을 적용하여 보안을 강화했습니다.
![ㅁㅁㄴㅇㅁㄴㅇㅁㄴㅇ](https://user-images.githubusercontent.com/38309884/109619052-a71fb900-7b7b-11eb-987f-c047cd561f72.PNG)
비밀번호와 salt 값을 바이트 범위로 인코딩 후 합쳐주고 다이제스트 업데이트할 때 사용해줍니다. digest() 메소드를 통해 업데이트된 값을 가져오고 그 값들을  HexString으로 변환하여 비밀번호로 저장합니다.
![비밀번호 확인](https://user-images.githubusercontent.com/38309884/109620630-750f5680-7b7d-11eb-85ca-b88bb521bee2.PNG)
DB에 저장된 내용을 보면 회원가입을 통해 입력한 내용하고 전혀 다른 값이 저장된 것을 확인할 수 있고 로그인을 할 때도 위에 메소드를 이용하여 비밀번호를 해시 알고리즘에 적용할 경우 DB에 저장된 값 같은 값이 나와 로그인에 성공한 모습을 확인할 수 있다.
![로그인 최종](https://user-images.githubusercontent.com/38309884/109625267-74c58a00-7b82-11eb-8a44-66a8e2ee59b8.PNG)
## 접근 제한
현재 페이지 이동은 a 태그와 button 태그를 통해 이루어지는데 만약 URL을 안다면 브라우저에 URL을 입력하여 원하는 위치로 이동할 수 있습니다. 그럼 만약 일반 사용자가 관리자 페이지 URL을 입력할 경우 관리자 페이지에 들어올 수 있기 때문에 관리자가 아닌 사용자의 접근을 막았습니다.
![인터셉터](https://user-images.githubusercontent.com/38309884/109610560-43dc5980-7b70-11eb-9dd6-7b393b76e989.PNG)
특정 경로로 접근할 경우 미리 설정된 클래스가 실행되게 spring-servlet.xml에 설정합니다.
![인터셉0](https://user-images.githubusercontent.com/38309884/109610564-4474f000-7b70-11eb-816e-c4f7d2f96e27.PNG)
preHandle과 postHandle을 통해 처리가 가능합니다. preHandle는 controller로 보내기 전에 처리하고 postHandle은 controller의 handler가 끝나면 처리됩니다.
  
접근을 막기위해 설정했기 때문에 preHandle에 내용을 추가했습니다. 현재 로그인 기능이 관리자 로그인 뿐이기 때문에 로그인 여부를 통해 판단을 했지만, 일반 사용자 로그인과 관리자 로그인이 나누어진 경우면 DB에 그 정보를 저장하는 컬럼을 추가하고 그 정보를 통해 막으면 될 것으로 예상합니다.
#	쿠키와 세션
쿠키와 세션은 웹 통신간 유지하려는 정보를 저장하기 위해 사용되는 방법입니다.
![메인 화면](https://user-images.githubusercontent.com/38309884/109605288-45a21f00-7b68-11eb-8d8a-0900dd765520.png)
위에 사진에서 빨간 박스에 있는 내용은 관리자 페이지를 제외한 모든 페이지에 사용되기 때문에 계속 DB에 접근하여 값을 가져오는 건 비효율적이라고 생각했고, 세션을 사용하여 서버의 저장하면 사용자가 늘어남에 따라 서버의 큰 부담이 될 것으로 예상되어 쿠키를 통해 값을 저장하고 저장된 값을 사용하는 방법을 생각했습니다.

그러나 문제가 있었던 게 빨간 박스의 내용을 저장하기 위해 게시판 목록이 저장된 List와 커뮤니티 게시판의 최신 글들이 저장된 List를 Map으로 저장해서 보내려 했지만, 쿠키의 경우 text만 지원되고, 용량 제한, 만료 시점 등 더 고려할 사항들이 있다는 점을 뒤늦게 파악했습니다.
  
쿠키와 세션의 차이
![asd](https://user-images.githubusercontent.com/38309884/109605558-b0ebf100-7b68-11eb-9199-9d5b6d820ad4.PNG)

현재 코드는 임시로 세션으로 저장하는 방식으로 만들어 이미 사이트에 들어온 사람은 그 이후에 만들어진 게시판을 못 보는 등 저장된 값을 가져와 사용할 경우 발생하는 문제점을 파악하는 중이고, 이 부분에 대한 정리를 다시 한 후 쿠키에 대한 시도를 다시 할 계획입니다.
  
# 삭제와 복구
지난 교육 때 클라이언트에서 삭제 요청이 오면 DB에 저장된 데이터를 지우는 것이 맞는지 간단하게 이야기가 나온 적이 있었는데 그때 당시에는 크게 생각을 안 하고 저장된 데이터를 지웠습니다.
  
그러다 최근 면접을 보면서 다시 생각해본 게 만약 사용자가 실수로 삭제한 데이터에 대해 복구를 신청할 경우 어떻게 처리할까에 대해 고민하게 되었습니다. 만약 DB에 데이터를 지우면 지우기 전으로 완전히 돌려야 하는데 그러면 다른 사용자들이 추가하고 변경된 내용도 이전으로 돌아가게 되어 큰 문제가 발생할 거라 생각이 되었습니다.
  
이 부분을 해결하기 위해 테이블에 삭제를 판단하는 컬럼을 추가하여 삭제되었는지만 판단하고 실제 데이터는 남아있는 방식을 생각하게 되었습니다.
  
변경 전 테이블
![전](https://user-images.githubusercontent.com/38309884/109602869-49cc3d80-7b64-11eb-86b9-271d3eb272d1.png)
변경 후 테이블
![후](https://user-images.githubusercontent.com/38309884/109602873-4a64d400-7b64-11eb-82e2-7a5bc683e617.png)
변경된 쿼리
![zhem](https://user-images.githubusercontent.com/38309884/109603634-69b03100-7b65-11eb-800f-5069cf6afe2e.PNG)
모든 쿼리문에도 미리 삭제를 판단하기 때문에 isDelete 값을 확인하는 내용을 추가했습니다.